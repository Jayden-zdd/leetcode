# 代码随想录算法第32天|动态规划
## 学习的文章链接和视频链接
1. 理论基础 
https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 
509. 斐波那契数 
https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html  
70. 爬楼梯   
https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html  
746. 使用最小花费爬楼梯 
https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html   
## 看到题目的第一想法
1、递归实现，时间复杂度2的N次方
## 实现过程中遇到哪些困难 
1、递归无困难，三部曲：入参、迭代公式、终止条件
2、动态规划：dp初始值第二个会越界，for循环时与递归弄混写成dp[n]
## 看完代码随想录之后的想法 
动态规划总结：
* 想清楚dp[i]的表示意义
* 写出循环遍历和推导公式
* 初始值赋值并解决越界
* 返回df[n]，必要可以打印出来
## 今日收获&学习时长
刷了3道题，学习时长2h
```Python
# 455.分发饼干  
g.sort()
        s.sort()
        result = 0
        j = len(s) - 1 
        for i in range(len(g)-1,-1,-1):
            while j >= 0 and s[j] >= g[i]:
                result += 1
                j -= 1
                break
        return result
# 376. 摆动序列  
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return n 
        result = 1 #数组尾端默认有个1，比如[2,5]遍历2计算result=1，实际是2
        prediff = 0
        for i in range(n-1):
            curdiff = nums[i+1] - nums[i]
            if (prediff >= 0 and curdiff < 0 ) or (prediff <=0 and curdiff > 0): #prediff= 0 是有平坡的特殊处理，删除平坡左边的数据，比如[1,2,2,1]
                result += 1
                prediff = curdiff#摆动的时候更新prediff，比如[1,2,2,2,3,4]
        return result
    # 初始自我想法
    # def wiggleMaxLength(self, nums: List[int]) -> int:
    #     n = len(nums)
    #     result = []
    #     i= 0
    #     while i < n-2:
    #         j = i + 1
    #         if j < n-1 and nums[j] == nums[i]:
    #             j += 1
    #         k = j + 1
    #         while k < n:
    #             res = cmpare(nums[i],nums[j],nums[k])
    #             if res:
    #                 result.append(nums[i])
    #                 result.append(nums[j])
    #                 i = k
    #                 break
    #             else:
    #                 k += 1
    #     return len(result)

    # def cmpare(a,b,c):
    #     if (b - a) * (b - c) < 0:
    #         return True
    #     else:
    #         return False

TODO：53   
```